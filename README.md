# README - Moderniza√ß√£o de Aplica√ß√£o PHP com DevOps

## üöÄ Vis√£o Geral
Este reposit√≥rio implementa a moderniza√ß√£o de uma aplica√ß√£o web simples em PHP, conforme o desafio do teste t√©cnico para Analista DevOps. A aplica√ß√£o original √© um "Hello World" em PHP, servida via Apache. O foco √© transformar o processo manual de deploy em uma abordagem automatizada e segura, usando containeriza√ß√£o, CI/CD e infraestrutura como c√≥digo (IaC).

Atualmente, deploys manuais via SSH causam riscos e lentid√£o. Minha solu√ß√£o cria uma funda√ß√£o s√≥lida:
- **Containeriza√ß√£o**: Imagem Docker otimizada.
- **CI**: Pipeline automatizado para build, teste e push.
- **IaC e CD**: Provisionamento na AWS com Terraform (escolhi ECS Fargate por simplicidade) e estrat√©gia para deploy autom√°tico.
- **Observabilidade**: Plano para monitoramento em produ√ß√£o.

Escolhi ferramentas acess√≠veis e padr√£o do mercado, priorizando seguran√ßa, portabilidade e custo baixo. O pipeline roda em GitHub Actions, e a infra √© provisionada na AWS. Como n√£o tenho credenciais reais de AWS, configurei o Terraform para valida√ß√£o local com valores fake.

## üìÇ Estrutura do Reposit√≥rio
```
‚îú‚îÄ‚îÄ .github/workflows/             # Pipeline CI/CD com GitHub Actions
‚îÇ ‚îî‚îÄ‚îÄ main.yml
‚îú‚îÄ‚îÄ app/                           # C√≥digo da aplica√ß√£o PHP
‚îÇ ‚îî‚îÄ‚îÄ index.php
‚îú‚îÄ‚îÄ docker-configs/                # Configura√ß√µes adicionais do container
‚îÇ ‚îî‚îÄ‚îÄ default.conf
‚îú‚îÄ‚îÄ k8s/                           # Manifests Kubernetes 
‚îÇ ‚îú‚îÄ‚îÄ deployment.yaml
‚îÇ ‚îú‚îÄ‚îÄ service.yaml
‚îÇ ‚îî‚îÄ‚îÄ kubectl
‚îú‚îÄ‚îÄ terraform/                     # Defini√ß√µes de infraestrutura IaC
‚îÇ ‚îú‚îÄ‚îÄ main.tf
‚îÇ ‚îú‚îÄ‚îÄ outputs.tf
‚îÇ ‚îú‚îÄ‚îÄ provider.tf
‚îÇ ‚îî‚îÄ‚îÄ variables.tf
‚îú‚îÄ‚îÄ Dockerfile                     # Imagem Docker da aplica√ß√£o
‚îú‚îÄ‚îÄ task-definition.json           # Defini√ß√µes para orquestradores
‚îî‚îÄ‚îÄ README.md
```

## ‚úÖ Etapa 1: Containeriza√ß√£o da Aplica√ß√£o

### Tarefa e Decis√µes
Criei um Dockerfile para containerizar a aplica√ß√£o PHP. Usei uma imagem base oficial do PHP para garantir compatibilidade e seguran√ßa.

- **Imagem Base**: `php:8.2-apache` (vers√£o LTS est√°vel). √â oficial, inclui Apache integrado e √© adequada para apps web simples. Evitei imagens customizadas para reduzir riscos.
- **Otimiza√ß√£o**: Implementei multi-stage build? N√£o diretamente, mas otimizei copiando apenas arquivos necess√°rios e limpando cache para manter a imagem leve (cerca de 400MB final).
- **Seguran√ßa**: 
  - Execu√ß√£o como usu√°rio n√£o-root (`www-data`), para evitar privil√©gios elevados em caso de brechas.
  - Exposi√ß√£o apenas da porta 80.
  - Coment√°rios no Dockerfile explicam cada layer: instala√ß√£o de depend√™ncias m√≠nimas, c√≥pia do c√≥digo para `/var/www/html`, e ajuste de permiss√µes.
- **Por qu√™?** Isso resolve o problema de "funciona na minha m√°quina", tornando o ambiente reproduz√≠vel em qualquer lugar.

### Teste Local
Para testar o container localmente:
```bash
docker build -t php-hello-app -f docker/Dockerfile .
docker run -p 8080:80 php-hello-app
```
Acesse http://localhost:8080 no navegador. Deve mostrar "Hello World - Aplica√ß√£o PHP rodando em container". Se der erro de permiss√£o, verifique o usu√°rio no Dockerfile.

## ‚úÖ Etapa 2: Cria√ß√£o do Pipeline de Integra√ß√£o Cont√≠nua (CI)

### Tarefa e Decis√µes
Criei um pipeline CI no GitHub Actions (arquivo `.github/workflows/main.yml`) que roda a cada push na branch `main`. √â acionado automaticamente e garante que s√≥ c√≥digo validado avance.

- **Passos do Pipeline**:
  1. **Checkout do C√≥digo**: Baixa o reposit√≥rio.
  2. **Build da Imagem Docker**: Constr√≥i a imagem usando o Dockerfile, taggeada com o SHA do commit para rastreabilidade.
  3. **An√°lise de Vulnerabilidades**: Usa Trivy para escanear a imagem. Configurado para falhar se encontrar vulnerabilidades CRITICAL ou HIGH (severidade alta). Isso bloqueia pushes inseguros.
  4. **Push para Docker Hub**: S√≥ na branch main, faz login seguro e publica a imagem com tags `${{ github.sha }}` e `latest`. Usa secrets do GitHub para autentica√ß√£o (nunca exp√µe credenciais no c√≥digo).

- **Ferramentas**: GitHub Actions (gratuito e integrado), Docker Buildx para build eficiente, Trivy (open-source, r√°pido para scans).
- **Segredos Necess√°rios**: No GitHub, adicione `DOCKERHUB_USERNAME` e `DOCKERHUB_TOKEN` (gere um token de acesso no Docker Hub, n√£o a senha).
- **Por qu√™?** Automatiza testes e valida√ß√µes, reduzindo erros manuais. O scan de seguran√ßa √© crucial para apps em produ√ß√£o, evitando deploys de imagens vulner√°veis.

### Como Executar o Pipeline
- Fa√ßa um `git push` para a branch `main`.
- Acompanhe no GitHub: Actions > main.yml. Deve buildar, scanear e pushar se tudo OK.
- Se falhar no scan, corrija o Dockerfile (ex: atualize a base image).

## ‚úÖ Etapa 3: Infraestrutura como C√≥digo (IaC) e Implanta√ß√£o (CD)

### Escolha da Tecnologia de Orquestra√ß√£o
Escolhi **AWS ECS com Fargate** em vez de EKS (Kubernetes) por estas raz√µes:
- **Simplicidade**: Fargate gerencia os containers sem precisar configurar n√≥s EC2 ou clusters complexos. Ideal para uma app simples e stateless como esta.
- **Custo e Overhead**: Mais barato para workloads pequenos (paga s√≥ pelo tempo de execu√ß√£o). EKS adiciona complexidade desnecess√°ria para um MVP.
- **Integra√ß√£o AWS**: Nativo da AWS, f√°cil de escalar com ALB e CloudWatch.
- **Justificativa Geral**: Para crescimento acelerado, Fargate permite foco no app, n√£o na infra. Se a app evoluir para microservices, migrar para EKS seria vi√°vel.

Inclu√≠ manifests alternativos para Kubernetes (deployment.yaml e service.yaml) na pasta `k8s/`, caso prefiram testar localmente com Minikube.

### C√≥digo Terraform (Pasta `infra/terraform/`)
Os arquivos Terraform provisionam uma infraestrutura b√°sica e idempotente na AWS:
- **providers.tf**: Configura o provider AWS (regi√£o us-east-1). Para testes sem credenciais reais, adicionei flags como `skip_credentials_validation = true` e chaves fake.
- **main.tf**: Define:
  - VPC e subnets (p√∫blicas/privadas para isolamento).
  - Cluster ECS e roles IAM (com permiss√µes m√≠nimas).
  - Application Load Balancer (ALB) para distribuir tr√°fego.
  - Task Definition (referencia a imagem do Docker Hub).
  - Servi√ßo ECS Fargate (roda 1 task, porta 80, auto-scaling b√°sico).
- **variables.tf**: Vari√°veis como `app_image` (ex: `laucapssa/php-hello-app:latest`), `vpc_id` e `subnet_ids`.
- **outputs.tf**: Exporta o DNS do ALB (ex: `app_url`) para acessar a app ap√≥s deploy.

Isso garante ambientes id√™nticos (dev/prod) e rastreabilidade via Git.

### Manifestos para Implanta√ß√£o
- **ECS**: `ecs/task-definition.json` define o container (`php-app`), porta 80, logs para CloudWatch e vari√°veis de ambiente. Integra com o Terraform.
- **Kubernetes (Opcional)**: `k8s/deployment.yaml` cria um Deployment com 2 r√©plicas, probes de health (liveness/readiness na porta 80). `k8s/service.yaml` exp√µe via LoadBalancer.

### Explica√ß√£o do CD (Extens√£o do Pipeline CI)
Para transformar o CI em CD, estenderia o `main.yml` adicionando um job final "Deploy" ap√≥s o push da imagem. Isso roda s√≥ na branch `main` e em ambiente de produ√ß√£o (usando approvals no GitHub).

- **Passos do CD**:
  1. **Configurar Credenciais AWS**: Usar a action `aws-actions/configure-aws-credentials` com secrets `AWS_ACCESS_KEY_ID` e `AWS_SECRET_ACCESS_KEY` (IAM com role de deploy, curta dura√ß√£o).
  2. **Terraform Apply**: No diret√≥rio `infra/terraform`, rode `terraform init`, `plan` (com vars como imagem taggeada) e `apply -auto-approve`. Isso provisiona/atualiza a infra se necess√°rio.
  3. **Atualizar e Deployar no ECS**: 
     - Use `aws-actions/amazon-ecs-render-task-definition` para atualizar a task definition com a nova imagem (tag SHA).
     - Em seguida, `aws-actions/amazon-ecs-deploy-task-definition` para for√ßar o deploy no servi√ßo ECS, esperando estabilidade.
  4. **Health Check**: Rode comandos AWS CLI para verificar tasks saud√°veis e o URL do ALB. Adicione sleep e curl para testar o endpoint.

- **Estrat√©gia de Implanta√ß√£o**: Rolling updates no ECS (zero downtime). Em falha, rollback manual via AWS Console ou Terraform destroy/apply anterior.
- **Por qu√™?** Cada push na main resulta em deploy autom√°tico, reduzindo tempo de semanas para minutos. Integra com o CI existente, mantendo scans de seguran√ßa.

### Valida√ß√£o do Terraform (Sem AWS Real)
```bash
cd infra/terraform
terraform init
terraform validate
terraform plan \
  -var="vpc_id=vpc-fake123" \
  -var='subnet_ids=["subnet-fake1", "subnet-fake2"]' \
  -var="app_image=laucapssa/php-hello-app:latest"
```
Isso simula o plan sem custos. Em produ√ß√£o, use IDs reais e credenciais.

## ‚úÖ Etapa 4: Estrat√©gia de Observabilidade

### Stack de Ferramentas Escolhida
Escolheria a stack nativa da AWS para simplicidade e integra√ß√£o: **CloudWatch + AWS X-Ray**. 
- **CloudWatch**: Para logs (do container) e m√©tricas (CPU, mem√≥ria, tr√°fego).
- **AWS X-Ray**: Para tracing de requests (√∫til em PHP para depurar lat√™ncia).
- **Por qu√™?** √â serverless, sem setup extra, e cobra s√≥ pelo uso. Para apps PHP em ECS, integra automaticamente via agent no task definition. Evita custos de ferramentas third-party como Prometheus/Grafana inicialmente; posso adicionar depois se precisar de dashboards customizados.

Alternativa para Economia de Custos
Para otimizar custos a longo prazo, especialmente se o volume de m√©tricas e logs crescer e o CloudWatch se tornar caro (devido a taxas de ingest√£o e armazenamento), eu consideraria migrar para uma stack open-source como Prometheus para coleta de m√©tricas e Grafana para visualiza√ß√£o e dashboards. O Prometheus pode ser rodado como um container no pr√≥prio ECS Fargate (com scraping autom√°tico das m√©tricas do app PHP via exporters como o Node Exporter ou Blackbox para endpoints HTTP), e o Grafana hospedado em uma inst√¢ncia EC2 t3.micro barata (cerca de US$ 5/m√™s). Essa abordagem elimina as taxas de dados do CloudWatch, mantendo a flexibilidade para alertas e queries avan√ßadas, e √© escal√°vel sem lock-in na AWS ‚Äì ideal para um crescimento acelerado onde os custos precisam ser controlados.

### 3 Principais M√©tricas para o Dashboard de Sa√∫de
Usaria CloudWatch Dashboards para monitorar essas m√©tricas chave, focando em UX, estabilidade e recursos:
1. **Lat√™ncia de Resposta (TargetResponseTime)**: Tempo m√©dio/p95 de requests no ALB ou container. Justificativa: Detecta lentid√£o na app PHP (ex: picos de usu√°rios), impactando a experi√™ncia. Alarme se > 500ms.
2. **Utiliza√ß√£o de CPU/Mem√≥ria (CPUUtilization e MemoryUtilization)**: % de uso no servi√ßo ECS. Justificativa: Previne sobrecarga; auto-scaling pode adicionar tasks se > 70%. Essencial para crescimento acelerado sem downtime.
3. **Erros HTTP (HTTPCode_Target_5XX_Count)**: Contagem de erros 5xx no target group do ALB. Justificativa: Indica falhas na app (ex: crashes PHP). Alarme imediato para rollback, garantindo estabilidade em produ√ß√£o.

Essas m√©tricas seriam coletadas a cada 1-5 minutos, com alarmes via SNS para notifica√ß√µes.

## üîç Como Rodar o Projeto

### Localmente (Docker)
```bash
docker build -t php-hello-app -f docker/Dockerfile .
docker run -p 8080:80 php-hello-app
```
Acesse http://localhost:8080.

### Pipeline CI (GitHub Actions)
- Adicione secrets no reposit√≥rio (Settings > Secrets).
- `git push origin main` ‚Äì Verifique em Actions.

### Infraestrutura (Terraform - Teste Local)
Use o comando de valida√ß√£o acima. Para deploy real:
```bash
cd infra/terraform
terraform init
terraform apply -var="app_image=laucapssa/php-hello-app:latest" -auto-approve
```
Acesse o output `app_url` no navegador.

### Kubernetes Local (Opcional, com Minikube)
```bash
minikube start
kubectl apply -f k8s/
minikube service php-service
```

## üìå Conclus√£o
Esta solu√ß√£o moderniza o ciclo de vida da aplica√ß√£o PHP, resolvendo gargalos de deploy manual com automa√ß√£o segura e escal√°vel. O CI garante qualidade, o IaC mant√©m consist√™ncia, e o CD (pronto para extens√£o) acelera lan√ßamentos. A observabilidade foca no essencial para monitorar sa√∫de. Como DevOps junior, priorizei pr√°ticas b√°sicas mas eficazes, como scans e n√£o-root, para um crescimento sustent√°vel. O reposit√≥rio √© pronto para evoluir ‚Äì sugest√µes bem-vindas! üöÄ